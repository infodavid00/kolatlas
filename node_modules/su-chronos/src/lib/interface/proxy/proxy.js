
"use strict";

import { request as HTTPSREQUEST } from "node:https";
import { request as HTTPREQUEST } from "node:http";
import { URL } from "node:url";

/**
 * respond to requests using the chronos proxy standard error format.
 * this proxy makes a request on behalve of the client and re-write the requests
 * cors policy.
 * 
 * @param {error} error - The error object.
 * @param {object} response - The response object.
 * @returns {void}
 */
function error(error, response) {
  response.statusCode = 500;
  response.setHeader("Content-Type", "text/plain");
  response.setHeader("X-Chronos-Proxy-Error", "true");
  /* when an error occurs, chronos specifies the `X-Chronos-Proxy-Error: true`
  ** header, and always sets the statusCode to 500.
  ** it is up to the client to implement how these errors are handled.
  ** NOTE, ERRORS FROM THE REMOTE SERVER EG 501's, 500's etc are sent 
  ** AS THE RESPONSE TO THE PROXY REQUEST NOT AS A PROXY ERROR (THIS).
  **/
  response.end(error.message);
}

/**
 * A simple and lightweight chronos internal proxy interface.
 * 
 * @author David.A super-user-d0
 * @param {object} request - The request object recieved from the http server. 
 * @param {object} response - The response object recieved from the http server. 
 */
export default async function proxyInterface(request, response) {
  try {
    /* DUE TO HOW THE GATEWAY HANDLES REQUESTS, THE PROXY SERVER CANNOT
    ** SUPPORT TRACE AND OPTIONS REQUESTS SINCE THE GATEWAY ALWAYS HANDLES THIS.
    **/ 
    let url = request.url.slice(1);
    url = atob(url);
    const maxByteLength = 512; // 512 Bytes
    const urlSize = Buffer.byteLength(url);

    if (urlSize > maxByteLength) {
      throw {
        message:
          `The url size when decoded must not exceed ${maxByteLength} Bytes, recieved ${urlSize}B`
      }
    }

    // always ensure URLS are intact as chronos does not provide a built in function
    // to validate this.
    url = new URL(url);
    const requestOptions = {
      insecureHTTPParser: true,
      headers: {},
      method: request.method
    };

    request.rawHeaders.forEach((header, index) => {
      if (index % 2 === 0) {
        let headerNameFormated = header.split("-").map(e => {
          e = e.trim();
          e = e[0].toUpperCase() + e.slice(1);
          return e;
        });
        headerNameFormated = headerNameFormated.join("-");
        requestOptions.headers[headerNameFormated] = request.rawHeaders[index + 1]
      }
    });
    // Remove chronos own request headers.
    requestOptions.headers["Srt"] = undefined;
    // this procedures removes any field with undefined as value. since one cannot
    // use the delete keyword on strict mode.
    requestOptions.headers = JSON.stringify(requestOptions.headers);
    requestOptions.headers = JSON.parse(requestOptions.headers);

    const socketParameters = [url, requestOptions, (res) => {
      let payload = "";
      res.setEncoding("utf-8"); // Sets character encoding to utf-8
      res.on("data", (chunk) => {
        payload += chunk;
      });
      res.on("end", () => {
        response.statusCode = res.statusCode;
        res.rawHeaders.forEach((header, index) => {
          if (index % 2 === 0) {
            const value = res.rawHeaders[index + 1]
            response.setHeader(header, value)
          }
        });
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Server", `${process.env["application.name"]}`);
        response.setHeader("X-Powered-By", "chronos-proxy");
        if (payload) response.end(payload)
        else response.end()
      });
    }]
    const _request =
      (url.protocol.slice(0, url.protocol.length - 1)) === "https" ?
        HTTPSREQUEST(...socketParameters) :
        HTTPREQUEST(...socketParameters)

    _request.on("error", (e) => {
      error(e, response);
    });
    
    if (request.body) _request.write(JSON.stringify(request.body));
    _request.end();

  } catch (e) {
    error(e, response);
  }
}
