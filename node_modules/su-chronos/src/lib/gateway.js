
"use strict";

import { _403TRACE } from "./interface/views/templates.js";
import kernelInterface from "./interface/kernel/kernel.js";
import proxyInterface from "./interface/proxy/proxy.js";
import server_options from "../global/server.options.js";
import { urlDecoder, rawBodyParser } from "../middlewares/@http_parser.js";
import viewInterface from "./interface/views/views.js";

/**
 * @param {object} request - The request object recieved from the http server. 
 * @param {object} response - The response object recieved from the http server. 
 */
function handleRequest(request, response) {
  const srtHeader = request.headers[process.env["newNamespace.srt"].toLowerCase()];
  response.setHeader("Date", new Date().toUTCString());
  response.setHeader("Server", `${process.env["application.name"]}`);
  response.setHeader("X-Powered-By", "chronos");

  const isOnDev =  
    ["prod", "review"].includes(process.env["application.releaseTag"]) ? false : true;
    
  let allowedOrigins = server_options().getOptions()?.cors?.allowOrigin;
  if (typeof allowedOrigins !== "string") allowedOrigins = false;

  /**/if (isOnDev) response.setHeader("Access-Control-Allow-Origin", "*");
  /**/else {
    /**/if (allowedOrigins) response.setHeader("Access-Control-Allow-Origin", allowedOrigins);
  /**/}
  /* WEIRD BUT OK!!!! THIS STUPID BLOCK NEEDS TO LOOK GOOD ATLEAST.*/

  if (request.method === "OPTIONS") {
      response.statusCode = 200;
      if (allowedOrigins)
        response.setHeader("Access-Control-Allow-Credentials", "true");
     
      if (isOnDev) {
        response.setHeader("Allow", "*");
        response.setHeader("Access-Control-Allow-Methods", "*");
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Max-Age", "31536000");
        response.setHeader("Access-Control-Allow-Credentials", "true");
        /* chronos caches the preflight request's response for approximately
        ** a year. this value was choosen in the sense that the chronos architecture for
        ** how preflight requests are handled on the developement would never change.
        */
      } else {
        if (allowedOrigins) {
            const allowedMethods = "GET, PUT, POST, DELETE, PATCH, HEAD, OPTIONS";
            response.setHeader("Allow", allowedMethods);
            response.setHeader("Access-Control-Allow-Methods", allowedMethods);
            response.setHeader("Access-Control-Max-Age", "3600"); 
            /* Cache the preflight request's response for AN hour to avoid uneccesary
            ** API calls. 
            ** IN CASES WHERE YOUR SERVER'S ALLOWED ORIGINS WILL NEVER CHANGE,
            ** CHRONOS RECOMMENDS SETTING THE Access-Control-Max-Age TO AN EXTREMELY 
            ** HIGH AMOUNT.
            ** NOTE THAT CHRONOS DOES NOT PROVIDE AN API FOR THIS MODIFICATION, THEREFORE IT
            ** MUST BE UPDATED FROM THIS CODEBASE.
            */
        }
      }
      response.end();

  } else if (request.method === "TRACE") {
      if (isOnDev) {
         const capitalizeWord = word => {
           const newWord = word[0].toUpperCase()+ word.slice(1);
           return newWord;
         }
        const requestHeaders = request.headers;
        const requestLine = `${request.method} ${request.url} HTTP/${request.httpVersion}`;
        let headers = "";
        Object.keys(requestHeaders).forEach(e => {
           headers += `${capitalizeWord(e)}: ${requestHeaders[e]}\r\n`;
        });
        const body =
           request.body && requestHeaders["content-type"] === "application/json" ?
              JSON.stringify(request.body, null, 3) : request.body ?? "";
        response.statusCode = 200;
        response.setHeader("Content-Type", "text/plain");  
        response.end(requestLine + "\r\n" + headers + "\r\n" + body);
        //echoback request.
      } else {
        response.statusCode = 403;
        response.setHeader("Content-Type", "text/html;charset=UTF-8");
        response.end(_403TRACE);
      }
      
  } else {
      if (srtHeader && srtHeader === "main") {
         rawBodyParser(request, response, kernelInterface);
      } else if (srtHeader && srtHeader === "proxy") {
         rawBodyParser(request, response, proxyInterface);
      } else {
         if (request.method === "GET" || request.method === "HEAD") {
            response.setHeader("X-Content-Type-Options", "nosniff");
            response.setHeader("X-Frame-Options", "SAMEORIGIN");
            response.setHeader("X-XSS-Protection", "1; mode=block");
            viewInterface(request, response);
         }
         else {
            response.statusCode = 400;
            response.setHeader("Content-Type", "text/plain");
            response.end(
               `The requested resource expected a HTTP/s method of type GET, HEAD or OPTIONS, but recieved ${request.method}.`
            );
         }
      } /*DID NOT PROCESS THE REQUEST PAYLOAD SINCE ITS TYPICALLY NOT NEEDED WHEN SERVING
        * STATIC FILES AS THE SERVER ONLY ACCEPTS GET or HEAD METHOD.
        */
  }
}

/**
 * The default gateway of the chronos server. this function acts as the gatekeeper of 
 * the server, examining every request and routing them to their appropriate interface.
 * 
 * @author David.A super-user-d0
 * @param {object} request - The request object recieved from the http server. 
 * @param {object} response - The response object recieved from the http server. 
 */
export default function gateway(request, response) {
  urlDecoder(request, response, handleRequest); //always decode the url of every request.
}
